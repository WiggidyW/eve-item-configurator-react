// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "weve_esi.proto" (package "weve_esi_proto", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message weve_esi_proto.Entity
 */
export interface Entity {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: string token = 2;
     */
    token: string;
}
/**
 * @generated from protobuf message weve_esi_proto.MarketOrder
 */
export interface MarketOrder {
    /**
     * @generated from protobuf field: int64 quantity = 1;
     */
    quantity: bigint;
    /**
     * @generated from protobuf field: double price = 2;
     */
    price: number;
}
/**
 * @generated from protobuf message weve_esi_proto.MarketOrdersRep
 */
export interface MarketOrdersRep {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.MarketOrder inner = 1;
     */
    inner: MarketOrder[]; // no particular order
}
/**
 * Request and Response Types
 *
 * @generated from protobuf message weve_esi_proto.MarketOrdersReq
 */
export interface MarketOrdersReq {
    /**
     * @generated from protobuf field: uint64 location_id = 1;
     */
    locationId: bigint;
    /**
     * @generated from protobuf field: uint32 type_id = 2;
     */
    typeId: number;
    /**
     * @generated from protobuf field: string token = 3;
     */
    token: string;
    /**
     * @generated from protobuf field: bool buy = 4;
     */
    buy: boolean;
}
/**
 * @generated from protobuf message weve_esi_proto.MultiMarketOrderRep
 */
export interface MultiMarketOrderRep {
    /**
     * @generated from protobuf field: weve_esi_proto.MarketOrdersReq req = 1;
     */
    req?: MarketOrdersReq;
    /**
     * @generated from protobuf field: weve_esi_proto.MarketOrdersRep rep = 2;
     */
    rep?: MarketOrdersRep;
}
/**
 * @generated from protobuf message weve_esi_proto.MultiMarketOrdersRep
 */
export interface MultiMarketOrdersRep {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.MultiMarketOrderRep inner = 1;
     */
    inner: MultiMarketOrderRep[];
}
/**
 * @generated from protobuf message weve_esi_proto.MultiMarketOrdersReq
 */
export interface MultiMarketOrdersReq {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.MarketOrdersReq inner = 1;
     */
    inner: MarketOrdersReq[];
}
/**
 * uint32 is typeid
 *
 * @generated from protobuf message weve_esi_proto.AdjustedPriceRep
 */
export interface AdjustedPriceRep {
    /**
     * @generated from protobuf field: map<uint32, double> inner = 1;
     */
    inner: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message weve_esi_proto.AdjustedPriceReq
 */
export interface AdjustedPriceReq {
}
/**
 * @generated from protobuf message weve_esi_proto.SystemIndex
 */
export interface SystemIndex {
    /**
     * @generated from protobuf field: double manufacturing = 1;
     */
    manufacturing: number;
    /**
     * @generated from protobuf field: double research_te = 2;
     */
    researchTe: number;
    /**
     * @generated from protobuf field: double research_me = 3;
     */
    researchMe: number;
    /**
     * @generated from protobuf field: double copying = 4;
     */
    copying: number;
    /**
     * @generated from protobuf field: double invention = 5;
     */
    invention: number;
    /**
     * @generated from protobuf field: double reactions = 6;
     */
    reactions: number;
}
/**
 * uint32 is systemid
 *
 * @generated from protobuf message weve_esi_proto.SystemIndexRep
 */
export interface SystemIndexRep {
    /**
     * @generated from protobuf field: map<uint32, weve_esi_proto.SystemIndex> inner = 1;
     */
    inner: {
        [key: number]: SystemIndex;
    };
}
/**
 * @generated from protobuf message weve_esi_proto.SystemIndexReq
 */
export interface SystemIndexReq {
}
/**
 * @generated from protobuf message weve_esi_proto.IndustryJob
 */
export interface IndustryJob {
    /**
     * @generated from protobuf field: uint64 location_id = 1;
     */
    locationId: bigint;
    /**
     * @generated from protobuf field: uint64 character_id = 2;
     */
    characterId: bigint;
    /**
     * @generated from protobuf field: uint64 start = 3;
     */
    start: bigint; // unix timestamp of when it started
    /**
     * @generated from protobuf field: uint64 finish = 4;
     */
    finish: bigint; // unix timestamp of when it finishes
    /**
     * @generated from protobuf field: double probability = 5;
     */
    probability: number; // always 1.0 unless invention
    /**
     * @generated from protobuf field: uint32 product_id = 6;
     */
    productId: number; // 0 if ME/TE research
    /**
     * @generated from protobuf field: uint32 blueprint_id = 7;
     */
    blueprintId: number;
    /**
     * @generated from protobuf field: int32 material_efficiency = 8;
     */
    materialEfficiency: number; // blueprint ME
    /**
     * @generated from protobuf field: int32 time_efficiency = 9;
     */
    timeEfficiency: number; // blueprint TE
    /**
     * @generated from protobuf field: int32 activity = 10;
     */
    activity: number;
    /**
     * @generated from protobuf field: int32 runs = 11;
     */
    runs: number;
    /**
     * @generated from protobuf field: bool is_bpc = 12;
     */
    isBpc: boolean;
}
/**
 * @generated from protobuf message weve_esi_proto.IndustryJobsRep
 */
export interface IndustryJobsRep {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.IndustryJob inner = 1;
     */
    inner: IndustryJob[];
}
/**
 * @generated from protobuf message weve_esi_proto.IndustryJobsReq
 */
export interface IndustryJobsReq {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity characters = 1;
     */
    characters: Entity[];
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity corporations = 2;
     */
    corporations: Entity[];
}
/**
 * assets and blueprints
 *
 * @generated from protobuf message weve_esi_proto.Asset
 */
export interface Asset {
    /**
     * @generated from protobuf field: uint64 entity_id = 1;
     */
    entityId: bigint;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: bigint;
    /**
     * @generated from protobuf field: int32 runs = 3;
     */
    runs: number;
    /**
     * @generated from protobuf field: int32 material_efficiency = 4;
     */
    materialEfficiency: number;
    /**
     * @generated from protobuf field: int32 time_efficiency = 5;
     */
    timeEfficiency: number;
    /**
     * @generated from protobuf field: repeated string flags = 6;
     */
    flags: string[]; // may include BPC or Singleton // NEVERMIND
}
/**
 * @generated from protobuf message weve_esi_proto.TypeAssets
 */
export interface TypeAssets {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Asset inner = 1;
     */
    inner: Asset[];
}
/**
 * uint32 is typeid
 *
 * @generated from protobuf message weve_esi_proto.LocationAssets
 */
export interface LocationAssets {
    /**
     * @generated from protobuf field: map<uint32, weve_esi_proto.TypeAssets> inner = 1;
     */
    inner: {
        [key: number]: TypeAssets;
    };
}
/**
 * only includes station assets, uint64 is locationid
 *
 * @generated from protobuf message weve_esi_proto.AssetsRep
 */
export interface AssetsRep {
    /**
     * @generated from protobuf field: map<uint64, weve_esi_proto.LocationAssets> inner = 1;
     */
    inner: {
        [key: string]: LocationAssets;
    };
}
/**
 * @generated from protobuf message weve_esi_proto.AssetsReq
 */
export interface AssetsReq {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity characters = 1;
     */
    characters: Entity[];
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity corporations = 2;
     */
    corporations: Entity[];
}
/**
 * @generated from protobuf message weve_esi_proto.Skills
 */
export interface Skills {
    /**
     * @generated from protobuf field: map<uint32, uint32> inner = 1;
     */
    inner: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message weve_esi_proto.SkillsRep
 */
export interface SkillsRep {
    /**
     * @generated from protobuf field: map<uint64, weve_esi_proto.Skills> inner = 1;
     */
    inner: {
        [key: string]: Skills;
    };
}
/**
 * @generated from protobuf message weve_esi_proto.SkillsReq
 */
export interface SkillsReq {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity characters = 1;
     */
    characters: Entity[];
}
/**
 * @generated from protobuf message weve_esi_proto.ActiveOrder
 */
export interface ActiveOrder {
    /**
     * @generated from protobuf field: bool buy = 1;
     */
    buy: boolean;
    /**
     * @generated from protobuf field: double price = 2;
     */
    price: number;
    /**
     * @generated from protobuf field: int64 quantity = 3;
     */
    quantity: bigint; // bool buy = 1;
    // uint64 location_id = 2;
    // uint32 type_id = 3;
    // double price = 4;
    // int64 quantity = 5;
}
/**
 * @generated from protobuf message weve_esi_proto.TypeActiveOrders
 */
export interface TypeActiveOrders {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.ActiveOrder inner = 1;
     */
    inner: ActiveOrder[];
}
/**
 * @generated from protobuf message weve_esi_proto.LocationActiveOrders
 */
export interface LocationActiveOrders {
    /**
     * @generated from protobuf field: map<uint32, weve_esi_proto.TypeActiveOrders> inner = 1;
     */
    inner: {
        [key: number]: TypeActiveOrders;
    };
}
/**
 * shouldn't include duplicates, uint64 is locationid
 *
 * @generated from protobuf message weve_esi_proto.ActiveOrdersRep
 */
export interface ActiveOrdersRep {
    /**
     * @generated from protobuf field: map<uint64, weve_esi_proto.LocationActiveOrders> inner = 1;
     */
    inner: {
        [key: string]: LocationActiveOrders;
    };
}
/**
 * @generated from protobuf message weve_esi_proto.ActiveOrdersReq
 */
export interface ActiveOrdersReq {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity characters = 1;
     */
    characters: Entity[];
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity corporations = 2;
     */
    corporations: Entity[];
}
/**
 * @generated from protobuf message weve_esi_proto.Transaction
 */
export interface Transaction {
    /**
     * @generated from protobuf field: bool buy = 1;
     */
    buy: boolean;
    /**
     * @generated from protobuf field: double price = 2;
     */
    price: number;
    /**
     * @generated from protobuf field: int64 quantity = 3;
     */
    quantity: bigint;
}
/**
 * @generated from protobuf message weve_esi_proto.TypeTransactions
 */
export interface TypeTransactions {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Transaction inner = 1;
     */
    inner: Transaction[];
}
/**
 * @generated from protobuf message weve_esi_proto.LocationTransactions
 */
export interface LocationTransactions {
    /**
     * @generated from protobuf field: map<uint32, weve_esi_proto.TypeTransactions> inner = 1;
     */
    inner: {
        [key: number]: TypeTransactions;
    };
}
/**
 * @generated from protobuf message weve_esi_proto.TransactionsRep
 */
export interface TransactionsRep {
    /**
     * @generated from protobuf field: map<uint64, weve_esi_proto.LocationTransactions> inner = 1;
     */
    inner: {
        [key: string]: LocationTransactions;
    };
}
/**
 * @generated from protobuf message weve_esi_proto.TransactionsReq
 */
export interface TransactionsReq {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity characters = 1;
     */
    characters: Entity[];
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity corporations = 2;
     */
    corporations: Entity[];
    /**
     * @generated from protobuf field: uint64 since = 3;
     */
    since: bigint;
}
/**
 * @generated from protobuf message weve_esi_proto.ExchangeContractItem
 */
export interface ExchangeContractItem {
    /**
     * @generated from protobuf field: uint32 type_id = 1;
     */
    typeId: number;
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: bigint;
}
/**
 * @generated from protobuf message weve_esi_proto.ExchangeContract
 */
export interface ExchangeContract {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.ExchangeContractItem items = 1;
     */
    items: ExchangeContractItem[];
    /**
     * @generated from protobuf field: uint64 location_id = 2;
     */
    locationId: bigint;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: double price = 4;
     */
    price: number;
    /**
     * @generated from protobuf field: double reward = 5;
     */
    reward: number;
    /**
     * @generated from protobuf field: uint64 expires = 6;
     */
    expires: bigint;
    /**
     * @generated from protobuf field: uint64 issued = 7;
     */
    issued: bigint;
    /**
     * @generated from protobuf field: double volume = 8;
     */
    volume: number;
    /**
     * @generated from protobuf field: uint32 char_id = 9;
     */
    charId: number;
    /**
     * @generated from protobuf field: uint32 corp_id = 10;
     */
    corpId: number;
    /**
     * @generated from protobuf field: bool is_corp = 11;
     */
    isCorp: boolean;
    /**
     * @generated from protobuf field: uint32 system_id = 12;
     */
    systemId: number;
    /**
     * @generated from protobuf field: uint32 region_id = 13;
     */
    regionId: number;
}
/**
 * @generated from protobuf message weve_esi_proto.ExchangeContractsRep
 */
export interface ExchangeContractsRep {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.ExchangeContract inner = 1;
     */
    inner: ExchangeContract[];
}
/**
 * @generated from protobuf message weve_esi_proto.ExchangeContractsReq
 */
export interface ExchangeContractsReq {
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity characters = 1;
     */
    characters: Entity[];
    /**
     * @generated from protobuf field: repeated weve_esi_proto.Entity corporations = 2;
     */
    corporations: Entity[];
    /**
     * @generated from protobuf field: bool active_only = 3;
     */
    activeOnly: boolean;
    /**
     * @generated from protobuf field: bool include_items = 4;
     */
    includeItems: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class Entity$Type extends MessageType<Entity> {
    constructor() {
        super("weve_esi_proto.Entity", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Entity>): Entity {
        const message = { id: 0n, token: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Entity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entity): Entity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Entity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.Entity
 */
export const Entity = new Entity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketOrder$Type extends MessageType<MarketOrder> {
    constructor() {
        super("weve_esi_proto.MarketOrder", [
            { no: 1, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<MarketOrder>): MarketOrder {
        const message = { quantity: 0n, price: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketOrder): MarketOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 quantity */ 1:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* double price */ 2:
                    message.price = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 quantity = 1; */
        if (message.quantity !== 0n)
            writer.tag(1, WireType.Varint).int64(message.quantity);
        /* double price = 2; */
        if (message.price !== 0)
            writer.tag(2, WireType.Bit64).double(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.MarketOrder
 */
export const MarketOrder = new MarketOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketOrdersRep$Type extends MessageType<MarketOrdersRep> {
    constructor() {
        super("weve_esi_proto.MarketOrdersRep", [
            { no: 1, name: "inner", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketOrder }
        ]);
    }
    create(value?: PartialMessage<MarketOrdersRep>): MarketOrdersRep {
        const message = { inner: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketOrdersRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketOrdersRep): MarketOrdersRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.MarketOrder inner */ 1:
                    message.inner.push(MarketOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketOrdersRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.MarketOrder inner = 1; */
        for (let i = 0; i < message.inner.length; i++)
            MarketOrder.internalBinaryWrite(message.inner[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.MarketOrdersRep
 */
export const MarketOrdersRep = new MarketOrdersRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketOrdersReq$Type extends MessageType<MarketOrdersReq> {
    constructor() {
        super("weve_esi_proto.MarketOrdersReq", [
            { no: 1, name: "location_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "type_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "buy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MarketOrdersReq>): MarketOrdersReq {
        const message = { locationId: 0n, typeId: 0, token: "", buy: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketOrdersReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketOrdersReq): MarketOrdersReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 location_id */ 1:
                    message.locationId = reader.uint64().toBigInt();
                    break;
                case /* uint32 type_id */ 2:
                    message.typeId = reader.uint32();
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                case /* bool buy */ 4:
                    message.buy = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketOrdersReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 location_id = 1; */
        if (message.locationId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.locationId);
        /* uint32 type_id = 2; */
        if (message.typeId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.typeId);
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        /* bool buy = 4; */
        if (message.buy !== false)
            writer.tag(4, WireType.Varint).bool(message.buy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.MarketOrdersReq
 */
export const MarketOrdersReq = new MarketOrdersReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultiMarketOrderRep$Type extends MessageType<MultiMarketOrderRep> {
    constructor() {
        super("weve_esi_proto.MultiMarketOrderRep", [
            { no: 1, name: "req", kind: "message", T: () => MarketOrdersReq },
            { no: 2, name: "rep", kind: "message", T: () => MarketOrdersRep }
        ]);
    }
    create(value?: PartialMessage<MultiMarketOrderRep>): MultiMarketOrderRep {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultiMarketOrderRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultiMarketOrderRep): MultiMarketOrderRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* weve_esi_proto.MarketOrdersReq req */ 1:
                    message.req = MarketOrdersReq.internalBinaryRead(reader, reader.uint32(), options, message.req);
                    break;
                case /* weve_esi_proto.MarketOrdersRep rep */ 2:
                    message.rep = MarketOrdersRep.internalBinaryRead(reader, reader.uint32(), options, message.rep);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultiMarketOrderRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* weve_esi_proto.MarketOrdersReq req = 1; */
        if (message.req)
            MarketOrdersReq.internalBinaryWrite(message.req, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* weve_esi_proto.MarketOrdersRep rep = 2; */
        if (message.rep)
            MarketOrdersRep.internalBinaryWrite(message.rep, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.MultiMarketOrderRep
 */
export const MultiMarketOrderRep = new MultiMarketOrderRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultiMarketOrdersRep$Type extends MessageType<MultiMarketOrdersRep> {
    constructor() {
        super("weve_esi_proto.MultiMarketOrdersRep", [
            { no: 1, name: "inner", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MultiMarketOrderRep }
        ]);
    }
    create(value?: PartialMessage<MultiMarketOrdersRep>): MultiMarketOrdersRep {
        const message = { inner: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultiMarketOrdersRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultiMarketOrdersRep): MultiMarketOrdersRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.MultiMarketOrderRep inner */ 1:
                    message.inner.push(MultiMarketOrderRep.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultiMarketOrdersRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.MultiMarketOrderRep inner = 1; */
        for (let i = 0; i < message.inner.length; i++)
            MultiMarketOrderRep.internalBinaryWrite(message.inner[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.MultiMarketOrdersRep
 */
export const MultiMarketOrdersRep = new MultiMarketOrdersRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultiMarketOrdersReq$Type extends MessageType<MultiMarketOrdersReq> {
    constructor() {
        super("weve_esi_proto.MultiMarketOrdersReq", [
            { no: 1, name: "inner", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketOrdersReq }
        ]);
    }
    create(value?: PartialMessage<MultiMarketOrdersReq>): MultiMarketOrdersReq {
        const message = { inner: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MultiMarketOrdersReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultiMarketOrdersReq): MultiMarketOrdersReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.MarketOrdersReq inner */ 1:
                    message.inner.push(MarketOrdersReq.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultiMarketOrdersReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.MarketOrdersReq inner = 1; */
        for (let i = 0; i < message.inner.length; i++)
            MarketOrdersReq.internalBinaryWrite(message.inner[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.MultiMarketOrdersReq
 */
export const MultiMarketOrdersReq = new MultiMarketOrdersReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdjustedPriceRep$Type extends MessageType<AdjustedPriceRep> {
    constructor() {
        super("weve_esi_proto.AdjustedPriceRep", [
            { no: 1, name: "inner", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } }
        ]);
    }
    create(value?: PartialMessage<AdjustedPriceRep>): AdjustedPriceRep {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdjustedPriceRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdjustedPriceRep): AdjustedPriceRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, double> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: AdjustedPriceRep["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AdjustedPriceRep["inner"] | undefined, val: AdjustedPriceRep["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.AdjustedPriceRep.inner");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: AdjustedPriceRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, double> inner = 1; */
        for (let k of Object.keys(message.inner))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Bit64).double(message.inner[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.AdjustedPriceRep
 */
export const AdjustedPriceRep = new AdjustedPriceRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdjustedPriceReq$Type extends MessageType<AdjustedPriceReq> {
    constructor() {
        super("weve_esi_proto.AdjustedPriceReq", []);
    }
    create(value?: PartialMessage<AdjustedPriceReq>): AdjustedPriceReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdjustedPriceReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdjustedPriceReq): AdjustedPriceReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AdjustedPriceReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.AdjustedPriceReq
 */
export const AdjustedPriceReq = new AdjustedPriceReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemIndex$Type extends MessageType<SystemIndex> {
    constructor() {
        super("weve_esi_proto.SystemIndex", [
            { no: 1, name: "manufacturing", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "research_te", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "research_me", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "copying", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "invention", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "reactions", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SystemIndex>): SystemIndex {
        const message = { manufacturing: 0, researchTe: 0, researchMe: 0, copying: 0, invention: 0, reactions: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SystemIndex>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemIndex): SystemIndex {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double manufacturing */ 1:
                    message.manufacturing = reader.double();
                    break;
                case /* double research_te */ 2:
                    message.researchTe = reader.double();
                    break;
                case /* double research_me */ 3:
                    message.researchMe = reader.double();
                    break;
                case /* double copying */ 4:
                    message.copying = reader.double();
                    break;
                case /* double invention */ 5:
                    message.invention = reader.double();
                    break;
                case /* double reactions */ 6:
                    message.reactions = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SystemIndex, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double manufacturing = 1; */
        if (message.manufacturing !== 0)
            writer.tag(1, WireType.Bit64).double(message.manufacturing);
        /* double research_te = 2; */
        if (message.researchTe !== 0)
            writer.tag(2, WireType.Bit64).double(message.researchTe);
        /* double research_me = 3; */
        if (message.researchMe !== 0)
            writer.tag(3, WireType.Bit64).double(message.researchMe);
        /* double copying = 4; */
        if (message.copying !== 0)
            writer.tag(4, WireType.Bit64).double(message.copying);
        /* double invention = 5; */
        if (message.invention !== 0)
            writer.tag(5, WireType.Bit64).double(message.invention);
        /* double reactions = 6; */
        if (message.reactions !== 0)
            writer.tag(6, WireType.Bit64).double(message.reactions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.SystemIndex
 */
export const SystemIndex = new SystemIndex$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemIndexRep$Type extends MessageType<SystemIndexRep> {
    constructor() {
        super("weve_esi_proto.SystemIndexRep", [
            { no: 1, name: "inner", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => SystemIndex } }
        ]);
    }
    create(value?: PartialMessage<SystemIndexRep>): SystemIndexRep {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SystemIndexRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemIndexRep): SystemIndexRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, weve_esi_proto.SystemIndex> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SystemIndexRep["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SystemIndexRep["inner"] | undefined, val: SystemIndexRep["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = SystemIndex.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.SystemIndexRep.inner");
            }
        }
        map[key ?? 0] = val ?? SystemIndex.create();
    }
    internalBinaryWrite(message: SystemIndexRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, weve_esi_proto.SystemIndex> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            SystemIndex.internalBinaryWrite(message.inner[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.SystemIndexRep
 */
export const SystemIndexRep = new SystemIndexRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SystemIndexReq$Type extends MessageType<SystemIndexReq> {
    constructor() {
        super("weve_esi_proto.SystemIndexReq", []);
    }
    create(value?: PartialMessage<SystemIndexReq>): SystemIndexReq {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SystemIndexReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SystemIndexReq): SystemIndexReq {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SystemIndexReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.SystemIndexReq
 */
export const SystemIndexReq = new SystemIndexReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndustryJob$Type extends MessageType<IndustryJob> {
    constructor() {
        super("weve_esi_proto.IndustryJob", [
            { no: 1, name: "location_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "character_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "start", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "finish", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "probability", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "product_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "blueprint_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "material_efficiency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "time_efficiency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "activity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "runs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "is_bpc", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<IndustryJob>): IndustryJob {
        const message = { locationId: 0n, characterId: 0n, start: 0n, finish: 0n, probability: 0, productId: 0, blueprintId: 0, materialEfficiency: 0, timeEfficiency: 0, activity: 0, runs: 0, isBpc: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndustryJob>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndustryJob): IndustryJob {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 location_id */ 1:
                    message.locationId = reader.uint64().toBigInt();
                    break;
                case /* uint64 character_id */ 2:
                    message.characterId = reader.uint64().toBigInt();
                    break;
                case /* uint64 start */ 3:
                    message.start = reader.uint64().toBigInt();
                    break;
                case /* uint64 finish */ 4:
                    message.finish = reader.uint64().toBigInt();
                    break;
                case /* double probability */ 5:
                    message.probability = reader.double();
                    break;
                case /* uint32 product_id */ 6:
                    message.productId = reader.uint32();
                    break;
                case /* uint32 blueprint_id */ 7:
                    message.blueprintId = reader.uint32();
                    break;
                case /* int32 material_efficiency */ 8:
                    message.materialEfficiency = reader.int32();
                    break;
                case /* int32 time_efficiency */ 9:
                    message.timeEfficiency = reader.int32();
                    break;
                case /* int32 activity */ 10:
                    message.activity = reader.int32();
                    break;
                case /* int32 runs */ 11:
                    message.runs = reader.int32();
                    break;
                case /* bool is_bpc */ 12:
                    message.isBpc = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndustryJob, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 location_id = 1; */
        if (message.locationId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.locationId);
        /* uint64 character_id = 2; */
        if (message.characterId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.characterId);
        /* uint64 start = 3; */
        if (message.start !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.start);
        /* uint64 finish = 4; */
        if (message.finish !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.finish);
        /* double probability = 5; */
        if (message.probability !== 0)
            writer.tag(5, WireType.Bit64).double(message.probability);
        /* uint32 product_id = 6; */
        if (message.productId !== 0)
            writer.tag(6, WireType.Varint).uint32(message.productId);
        /* uint32 blueprint_id = 7; */
        if (message.blueprintId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.blueprintId);
        /* int32 material_efficiency = 8; */
        if (message.materialEfficiency !== 0)
            writer.tag(8, WireType.Varint).int32(message.materialEfficiency);
        /* int32 time_efficiency = 9; */
        if (message.timeEfficiency !== 0)
            writer.tag(9, WireType.Varint).int32(message.timeEfficiency);
        /* int32 activity = 10; */
        if (message.activity !== 0)
            writer.tag(10, WireType.Varint).int32(message.activity);
        /* int32 runs = 11; */
        if (message.runs !== 0)
            writer.tag(11, WireType.Varint).int32(message.runs);
        /* bool is_bpc = 12; */
        if (message.isBpc !== false)
            writer.tag(12, WireType.Varint).bool(message.isBpc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.IndustryJob
 */
export const IndustryJob = new IndustryJob$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndustryJobsRep$Type extends MessageType<IndustryJobsRep> {
    constructor() {
        super("weve_esi_proto.IndustryJobsRep", [
            { no: 1, name: "inner", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IndustryJob }
        ]);
    }
    create(value?: PartialMessage<IndustryJobsRep>): IndustryJobsRep {
        const message = { inner: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndustryJobsRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndustryJobsRep): IndustryJobsRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.IndustryJob inner */ 1:
                    message.inner.push(IndustryJob.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndustryJobsRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.IndustryJob inner = 1; */
        for (let i = 0; i < message.inner.length; i++)
            IndustryJob.internalBinaryWrite(message.inner[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.IndustryJobsRep
 */
export const IndustryJobsRep = new IndustryJobsRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndustryJobsReq$Type extends MessageType<IndustryJobsReq> {
    constructor() {
        super("weve_esi_proto.IndustryJobsReq", [
            { no: 1, name: "characters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity },
            { no: 2, name: "corporations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<IndustryJobsReq>): IndustryJobsReq {
        const message = { characters: [], corporations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndustryJobsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndustryJobsReq): IndustryJobsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.Entity characters */ 1:
                    message.characters.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated weve_esi_proto.Entity corporations */ 2:
                    message.corporations.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndustryJobsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.Entity characters = 1; */
        for (let i = 0; i < message.characters.length; i++)
            Entity.internalBinaryWrite(message.characters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated weve_esi_proto.Entity corporations = 2; */
        for (let i = 0; i < message.corporations.length; i++)
            Entity.internalBinaryWrite(message.corporations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.IndustryJobsReq
 */
export const IndustryJobsReq = new IndustryJobsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Asset$Type extends MessageType<Asset> {
    constructor() {
        super("weve_esi_proto.Asset", [
            { no: 1, name: "entity_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "runs", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "material_efficiency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "time_efficiency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Asset>): Asset {
        const message = { entityId: 0n, quantity: 0n, runs: 0, materialEfficiency: 0, timeEfficiency: 0, flags: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Asset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Asset): Asset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 entity_id */ 1:
                    message.entityId = reader.uint64().toBigInt();
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* int32 runs */ 3:
                    message.runs = reader.int32();
                    break;
                case /* int32 material_efficiency */ 4:
                    message.materialEfficiency = reader.int32();
                    break;
                case /* int32 time_efficiency */ 5:
                    message.timeEfficiency = reader.int32();
                    break;
                case /* repeated string flags */ 6:
                    message.flags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Asset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 entity_id = 1; */
        if (message.entityId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.entityId);
        /* int64 quantity = 2; */
        if (message.quantity !== 0n)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        /* int32 runs = 3; */
        if (message.runs !== 0)
            writer.tag(3, WireType.Varint).int32(message.runs);
        /* int32 material_efficiency = 4; */
        if (message.materialEfficiency !== 0)
            writer.tag(4, WireType.Varint).int32(message.materialEfficiency);
        /* int32 time_efficiency = 5; */
        if (message.timeEfficiency !== 0)
            writer.tag(5, WireType.Varint).int32(message.timeEfficiency);
        /* repeated string flags = 6; */
        for (let i = 0; i < message.flags.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.flags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.Asset
 */
export const Asset = new Asset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeAssets$Type extends MessageType<TypeAssets> {
    constructor() {
        super("weve_esi_proto.TypeAssets", [
            { no: 1, name: "inner", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Asset }
        ]);
    }
    create(value?: PartialMessage<TypeAssets>): TypeAssets {
        const message = { inner: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TypeAssets>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeAssets): TypeAssets {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.Asset inner */ 1:
                    message.inner.push(Asset.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeAssets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.Asset inner = 1; */
        for (let i = 0; i < message.inner.length; i++)
            Asset.internalBinaryWrite(message.inner[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.TypeAssets
 */
export const TypeAssets = new TypeAssets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationAssets$Type extends MessageType<LocationAssets> {
    constructor() {
        super("weve_esi_proto.LocationAssets", [
            { no: 1, name: "inner", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => TypeAssets } }
        ]);
    }
    create(value?: PartialMessage<LocationAssets>): LocationAssets {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationAssets>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationAssets): LocationAssets {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, weve_esi_proto.TypeAssets> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: LocationAssets["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LocationAssets["inner"] | undefined, val: LocationAssets["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = TypeAssets.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.LocationAssets.inner");
            }
        }
        map[key ?? 0] = val ?? TypeAssets.create();
    }
    internalBinaryWrite(message: LocationAssets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, weve_esi_proto.TypeAssets> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TypeAssets.internalBinaryWrite(message.inner[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.LocationAssets
 */
export const LocationAssets = new LocationAssets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetsRep$Type extends MessageType<AssetsRep> {
    constructor() {
        super("weve_esi_proto.AssetsRep", [
            { no: 1, name: "inner", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => LocationAssets } }
        ]);
    }
    create(value?: PartialMessage<AssetsRep>): AssetsRep {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetsRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetsRep): AssetsRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint64, weve_esi_proto.LocationAssets> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: AssetsRep["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AssetsRep["inner"] | undefined, val: AssetsRep["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = LocationAssets.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.AssetsRep.inner");
            }
        }
        map[key ?? "0"] = val ?? LocationAssets.create();
    }
    internalBinaryWrite(message: AssetsRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint64, weve_esi_proto.LocationAssets> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            LocationAssets.internalBinaryWrite(message.inner[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.AssetsRep
 */
export const AssetsRep = new AssetsRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetsReq$Type extends MessageType<AssetsReq> {
    constructor() {
        super("weve_esi_proto.AssetsReq", [
            { no: 1, name: "characters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity },
            { no: 2, name: "corporations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<AssetsReq>): AssetsReq {
        const message = { characters: [], corporations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetsReq): AssetsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.Entity characters */ 1:
                    message.characters.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated weve_esi_proto.Entity corporations */ 2:
                    message.corporations.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.Entity characters = 1; */
        for (let i = 0; i < message.characters.length; i++)
            Entity.internalBinaryWrite(message.characters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated weve_esi_proto.Entity corporations = 2; */
        for (let i = 0; i < message.corporations.length; i++)
            Entity.internalBinaryWrite(message.corporations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.AssetsReq
 */
export const AssetsReq = new AssetsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Skills$Type extends MessageType<Skills> {
    constructor() {
        super("weve_esi_proto.Skills", [
            { no: 1, name: "inner", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } }
        ]);
    }
    create(value?: PartialMessage<Skills>): Skills {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Skills>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Skills): Skills {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, uint32> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Skills["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Skills["inner"] | undefined, val: Skills["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.Skills.inner");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: Skills, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, uint32> inner = 1; */
        for (let k of Object.keys(message.inner))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k)).tag(2, WireType.Varint).uint32(message.inner[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.Skills
 */
export const Skills = new Skills$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SkillsRep$Type extends MessageType<SkillsRep> {
    constructor() {
        super("weve_esi_proto.SkillsRep", [
            { no: 1, name: "inner", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => Skills } }
        ]);
    }
    create(value?: PartialMessage<SkillsRep>): SkillsRep {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SkillsRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SkillsRep): SkillsRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint64, weve_esi_proto.Skills> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SkillsRep["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SkillsRep["inner"] | undefined, val: SkillsRep["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = Skills.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.SkillsRep.inner");
            }
        }
        map[key ?? "0"] = val ?? Skills.create();
    }
    internalBinaryWrite(message: SkillsRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint64, weve_esi_proto.Skills> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Skills.internalBinaryWrite(message.inner[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.SkillsRep
 */
export const SkillsRep = new SkillsRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SkillsReq$Type extends MessageType<SkillsReq> {
    constructor() {
        super("weve_esi_proto.SkillsReq", [
            { no: 1, name: "characters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<SkillsReq>): SkillsReq {
        const message = { characters: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SkillsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SkillsReq): SkillsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.Entity characters */ 1:
                    message.characters.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SkillsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.Entity characters = 1; */
        for (let i = 0; i < message.characters.length; i++)
            Entity.internalBinaryWrite(message.characters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.SkillsReq
 */
export const SkillsReq = new SkillsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActiveOrder$Type extends MessageType<ActiveOrder> {
    constructor() {
        super("weve_esi_proto.ActiveOrder", [
            { no: 1, name: "buy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ActiveOrder>): ActiveOrder {
        const message = { buy: false, price: 0, quantity: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActiveOrder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActiveOrder): ActiveOrder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool buy */ 1:
                    message.buy = reader.bool();
                    break;
                case /* double price */ 2:
                    message.price = reader.double();
                    break;
                case /* int64 quantity */ 3:
                    message.quantity = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActiveOrder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool buy = 1; */
        if (message.buy !== false)
            writer.tag(1, WireType.Varint).bool(message.buy);
        /* double price = 2; */
        if (message.price !== 0)
            writer.tag(2, WireType.Bit64).double(message.price);
        /* int64 quantity = 3; */
        if (message.quantity !== 0n)
            writer.tag(3, WireType.Varint).int64(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.ActiveOrder
 */
export const ActiveOrder = new ActiveOrder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeActiveOrders$Type extends MessageType<TypeActiveOrders> {
    constructor() {
        super("weve_esi_proto.TypeActiveOrders", [
            { no: 1, name: "inner", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ActiveOrder }
        ]);
    }
    create(value?: PartialMessage<TypeActiveOrders>): TypeActiveOrders {
        const message = { inner: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TypeActiveOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeActiveOrders): TypeActiveOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.ActiveOrder inner */ 1:
                    message.inner.push(ActiveOrder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeActiveOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.ActiveOrder inner = 1; */
        for (let i = 0; i < message.inner.length; i++)
            ActiveOrder.internalBinaryWrite(message.inner[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.TypeActiveOrders
 */
export const TypeActiveOrders = new TypeActiveOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationActiveOrders$Type extends MessageType<LocationActiveOrders> {
    constructor() {
        super("weve_esi_proto.LocationActiveOrders", [
            { no: 1, name: "inner", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => TypeActiveOrders } }
        ]);
    }
    create(value?: PartialMessage<LocationActiveOrders>): LocationActiveOrders {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationActiveOrders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationActiveOrders): LocationActiveOrders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, weve_esi_proto.TypeActiveOrders> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: LocationActiveOrders["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LocationActiveOrders["inner"] | undefined, val: LocationActiveOrders["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = TypeActiveOrders.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.LocationActiveOrders.inner");
            }
        }
        map[key ?? 0] = val ?? TypeActiveOrders.create();
    }
    internalBinaryWrite(message: LocationActiveOrders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, weve_esi_proto.TypeActiveOrders> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TypeActiveOrders.internalBinaryWrite(message.inner[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.LocationActiveOrders
 */
export const LocationActiveOrders = new LocationActiveOrders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActiveOrdersRep$Type extends MessageType<ActiveOrdersRep> {
    constructor() {
        super("weve_esi_proto.ActiveOrdersRep", [
            { no: 1, name: "inner", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => LocationActiveOrders } }
        ]);
    }
    create(value?: PartialMessage<ActiveOrdersRep>): ActiveOrdersRep {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActiveOrdersRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActiveOrdersRep): ActiveOrdersRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint64, weve_esi_proto.LocationActiveOrders> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: ActiveOrdersRep["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ActiveOrdersRep["inner"] | undefined, val: ActiveOrdersRep["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = LocationActiveOrders.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.ActiveOrdersRep.inner");
            }
        }
        map[key ?? "0"] = val ?? LocationActiveOrders.create();
    }
    internalBinaryWrite(message: ActiveOrdersRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint64, weve_esi_proto.LocationActiveOrders> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            LocationActiveOrders.internalBinaryWrite(message.inner[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.ActiveOrdersRep
 */
export const ActiveOrdersRep = new ActiveOrdersRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActiveOrdersReq$Type extends MessageType<ActiveOrdersReq> {
    constructor() {
        super("weve_esi_proto.ActiveOrdersReq", [
            { no: 1, name: "characters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity },
            { no: 2, name: "corporations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<ActiveOrdersReq>): ActiveOrdersReq {
        const message = { characters: [], corporations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActiveOrdersReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActiveOrdersReq): ActiveOrdersReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.Entity characters */ 1:
                    message.characters.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated weve_esi_proto.Entity corporations */ 2:
                    message.corporations.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActiveOrdersReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.Entity characters = 1; */
        for (let i = 0; i < message.characters.length; i++)
            Entity.internalBinaryWrite(message.characters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated weve_esi_proto.Entity corporations = 2; */
        for (let i = 0; i < message.corporations.length; i++)
            Entity.internalBinaryWrite(message.corporations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.ActiveOrdersReq
 */
export const ActiveOrdersReq = new ActiveOrdersReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("weve_esi_proto.Transaction", [
            { no: 1, name: "buy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = { buy: false, price: 0, quantity: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool buy */ 1:
                    message.buy = reader.bool();
                    break;
                case /* double price */ 2:
                    message.price = reader.double();
                    break;
                case /* int64 quantity */ 3:
                    message.quantity = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool buy = 1; */
        if (message.buy !== false)
            writer.tag(1, WireType.Varint).bool(message.buy);
        /* double price = 2; */
        if (message.price !== 0)
            writer.tag(2, WireType.Bit64).double(message.price);
        /* int64 quantity = 3; */
        if (message.quantity !== 0n)
            writer.tag(3, WireType.Varint).int64(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TypeTransactions$Type extends MessageType<TypeTransactions> {
    constructor() {
        super("weve_esi_proto.TypeTransactions", [
            { no: 1, name: "inner", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<TypeTransactions>): TypeTransactions {
        const message = { inner: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TypeTransactions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TypeTransactions): TypeTransactions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.Transaction inner */ 1:
                    message.inner.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TypeTransactions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.Transaction inner = 1; */
        for (let i = 0; i < message.inner.length; i++)
            Transaction.internalBinaryWrite(message.inner[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.TypeTransactions
 */
export const TypeTransactions = new TypeTransactions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocationTransactions$Type extends MessageType<LocationTransactions> {
    constructor() {
        super("weve_esi_proto.LocationTransactions", [
            { no: 1, name: "inner", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => TypeTransactions } }
        ]);
    }
    create(value?: PartialMessage<LocationTransactions>): LocationTransactions {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LocationTransactions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocationTransactions): LocationTransactions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, weve_esi_proto.TypeTransactions> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: LocationTransactions["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LocationTransactions["inner"] | undefined, val: LocationTransactions["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = TypeTransactions.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.LocationTransactions.inner");
            }
        }
        map[key ?? 0] = val ?? TypeTransactions.create();
    }
    internalBinaryWrite(message: LocationTransactions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, weve_esi_proto.TypeTransactions> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TypeTransactions.internalBinaryWrite(message.inner[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.LocationTransactions
 */
export const LocationTransactions = new LocationTransactions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionsRep$Type extends MessageType<TransactionsRep> {
    constructor() {
        super("weve_esi_proto.TransactionsRep", [
            { no: 1, name: "inner", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "message", T: () => LocationTransactions } }
        ]);
    }
    create(value?: PartialMessage<TransactionsRep>): TransactionsRep {
        const message = { inner: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionsRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionsRep): TransactionsRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint64, weve_esi_proto.LocationTransactions> inner */ 1:
                    this.binaryReadMap1(message.inner, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TransactionsRep["inner"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TransactionsRep["inner"] | undefined, val: TransactionsRep["inner"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = LocationTransactions.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field weve_esi_proto.TransactionsRep.inner");
            }
        }
        map[key ?? "0"] = val ?? LocationTransactions.create();
    }
    internalBinaryWrite(message: TransactionsRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint64, weve_esi_proto.LocationTransactions> inner = 1; */
        for (let k of Object.keys(message.inner)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            LocationTransactions.internalBinaryWrite(message.inner[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.TransactionsRep
 */
export const TransactionsRep = new TransactionsRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionsReq$Type extends MessageType<TransactionsReq> {
    constructor() {
        super("weve_esi_proto.TransactionsReq", [
            { no: 1, name: "characters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity },
            { no: 2, name: "corporations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity },
            { no: 3, name: "since", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionsReq>): TransactionsReq {
        const message = { characters: [], corporations: [], since: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionsReq): TransactionsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.Entity characters */ 1:
                    message.characters.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated weve_esi_proto.Entity corporations */ 2:
                    message.corporations.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 since */ 3:
                    message.since = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.Entity characters = 1; */
        for (let i = 0; i < message.characters.length; i++)
            Entity.internalBinaryWrite(message.characters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated weve_esi_proto.Entity corporations = 2; */
        for (let i = 0; i < message.corporations.length; i++)
            Entity.internalBinaryWrite(message.corporations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 since = 3; */
        if (message.since !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.since);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.TransactionsReq
 */
export const TransactionsReq = new TransactionsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExchangeContractItem$Type extends MessageType<ExchangeContractItem> {
    constructor() {
        super("weve_esi_proto.ExchangeContractItem", [
            { no: 1, name: "type_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ExchangeContractItem>): ExchangeContractItem {
        const message = { typeId: 0, quantity: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExchangeContractItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExchangeContractItem): ExchangeContractItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_id */ 1:
                    message.typeId = reader.uint32();
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExchangeContractItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_id = 1; */
        if (message.typeId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeId);
        /* int64 quantity = 2; */
        if (message.quantity !== 0n)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.ExchangeContractItem
 */
export const ExchangeContractItem = new ExchangeContractItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExchangeContract$Type extends MessageType<ExchangeContract> {
    constructor() {
        super("weve_esi_proto.ExchangeContract", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExchangeContractItem },
            { no: 2, name: "location_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "reward", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "expires", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "issued", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "volume", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "char_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "corp_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "is_corp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "system_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "region_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExchangeContract>): ExchangeContract {
        const message = { items: [], locationId: 0n, description: "", price: 0, reward: 0, expires: 0n, issued: 0n, volume: 0, charId: 0, corpId: 0, isCorp: false, systemId: 0, regionId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExchangeContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExchangeContract): ExchangeContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.ExchangeContractItem items */ 1:
                    message.items.push(ExchangeContractItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 location_id */ 2:
                    message.locationId = reader.uint64().toBigInt();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* double price */ 4:
                    message.price = reader.double();
                    break;
                case /* double reward */ 5:
                    message.reward = reader.double();
                    break;
                case /* uint64 expires */ 6:
                    message.expires = reader.uint64().toBigInt();
                    break;
                case /* uint64 issued */ 7:
                    message.issued = reader.uint64().toBigInt();
                    break;
                case /* double volume */ 8:
                    message.volume = reader.double();
                    break;
                case /* uint32 char_id */ 9:
                    message.charId = reader.uint32();
                    break;
                case /* uint32 corp_id */ 10:
                    message.corpId = reader.uint32();
                    break;
                case /* bool is_corp */ 11:
                    message.isCorp = reader.bool();
                    break;
                case /* uint32 system_id */ 12:
                    message.systemId = reader.uint32();
                    break;
                case /* uint32 region_id */ 13:
                    message.regionId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExchangeContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.ExchangeContractItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            ExchangeContractItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 location_id = 2; */
        if (message.locationId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.locationId);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* double price = 4; */
        if (message.price !== 0)
            writer.tag(4, WireType.Bit64).double(message.price);
        /* double reward = 5; */
        if (message.reward !== 0)
            writer.tag(5, WireType.Bit64).double(message.reward);
        /* uint64 expires = 6; */
        if (message.expires !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.expires);
        /* uint64 issued = 7; */
        if (message.issued !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.issued);
        /* double volume = 8; */
        if (message.volume !== 0)
            writer.tag(8, WireType.Bit64).double(message.volume);
        /* uint32 char_id = 9; */
        if (message.charId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.charId);
        /* uint32 corp_id = 10; */
        if (message.corpId !== 0)
            writer.tag(10, WireType.Varint).uint32(message.corpId);
        /* bool is_corp = 11; */
        if (message.isCorp !== false)
            writer.tag(11, WireType.Varint).bool(message.isCorp);
        /* uint32 system_id = 12; */
        if (message.systemId !== 0)
            writer.tag(12, WireType.Varint).uint32(message.systemId);
        /* uint32 region_id = 13; */
        if (message.regionId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.regionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.ExchangeContract
 */
export const ExchangeContract = new ExchangeContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExchangeContractsRep$Type extends MessageType<ExchangeContractsRep> {
    constructor() {
        super("weve_esi_proto.ExchangeContractsRep", [
            { no: 1, name: "inner", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExchangeContract }
        ]);
    }
    create(value?: PartialMessage<ExchangeContractsRep>): ExchangeContractsRep {
        const message = { inner: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExchangeContractsRep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExchangeContractsRep): ExchangeContractsRep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.ExchangeContract inner */ 1:
                    message.inner.push(ExchangeContract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExchangeContractsRep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.ExchangeContract inner = 1; */
        for (let i = 0; i < message.inner.length; i++)
            ExchangeContract.internalBinaryWrite(message.inner[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.ExchangeContractsRep
 */
export const ExchangeContractsRep = new ExchangeContractsRep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExchangeContractsReq$Type extends MessageType<ExchangeContractsReq> {
    constructor() {
        super("weve_esi_proto.ExchangeContractsReq", [
            { no: 1, name: "characters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity },
            { no: 2, name: "corporations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Entity },
            { no: 3, name: "active_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_items", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExchangeContractsReq>): ExchangeContractsReq {
        const message = { characters: [], corporations: [], activeOnly: false, includeItems: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExchangeContractsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExchangeContractsReq): ExchangeContractsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated weve_esi_proto.Entity characters */ 1:
                    message.characters.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated weve_esi_proto.Entity corporations */ 2:
                    message.corporations.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool active_only */ 3:
                    message.activeOnly = reader.bool();
                    break;
                case /* bool include_items */ 4:
                    message.includeItems = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExchangeContractsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated weve_esi_proto.Entity characters = 1; */
        for (let i = 0; i < message.characters.length; i++)
            Entity.internalBinaryWrite(message.characters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated weve_esi_proto.Entity corporations = 2; */
        for (let i = 0; i < message.corporations.length; i++)
            Entity.internalBinaryWrite(message.corporations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool active_only = 3; */
        if (message.activeOnly !== false)
            writer.tag(3, WireType.Varint).bool(message.activeOnly);
        /* bool include_items = 4; */
        if (message.includeItems !== false)
            writer.tag(4, WireType.Varint).bool(message.includeItems);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message weve_esi_proto.ExchangeContractsReq
 */
export const ExchangeContractsReq = new ExchangeContractsReq$Type();
/**
 * @generated ServiceType for protobuf service weve_esi_proto.WeveEsi
 */
export const WeveEsi = new ServiceType("weve_esi_proto.WeveEsi", [
    { name: "ActiveOrders", options: {}, I: ActiveOrdersReq, O: ActiveOrdersRep },
    { name: "AdjustedPrice", options: {}, I: AdjustedPriceReq, O: AdjustedPriceRep },
    { name: "Assets", options: {}, I: AssetsReq, O: AssetsRep },
    { name: "IndustryJobs", options: {}, I: IndustryJobsReq, O: IndustryJobsRep },
    { name: "MarketOrders", options: {}, I: MarketOrdersReq, O: MarketOrdersRep },
    { name: "Skills", options: {}, I: SkillsReq, O: SkillsRep },
    { name: "SystemIndex", options: {}, I: SystemIndexReq, O: SystemIndexRep },
    { name: "Transactions", options: {}, I: TransactionsReq, O: TransactionsRep },
    { name: "ExchangeContracts", options: {}, I: ExchangeContractsReq, O: ExchangeContractsRep },
    { name: "MultiMarketOrders", options: {}, I: MultiMarketOrdersReq, O: MultiMarketOrdersRep }
]);
